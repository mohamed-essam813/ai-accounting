"use server";

import { revalidatePath } from "next/cache";
import { z } from "zod";
import { createServerSupabaseClient } from "@/lib/supabase/server";
import { getCurrentUser } from "@/lib/data/users";
import type { Database } from "@/lib/database.types";

type ContactsInsert = Database["public"]["Tables"]["contacts"]["Insert"];
type ContactsUpdate = Database["public"]["Tables"]["contacts"]["Update"];
type ContactsRow = Database["public"]["Tables"]["contacts"]["Row"];
type AuditLogsInsert = Database["public"]["Tables"]["audit_logs"]["Insert"];

const ContactSchema = z.object({
  name: z.string().min(1, "Name is required"),
  type: z.enum(["customer", "vendor", "other"]),
  email: z.string().email().optional().or(z.literal("")),
  phone: z.string().optional().or(z.literal("")),
  address: z.string().optional().or(z.literal("")),
  tax_id: z.string().optional().or(z.literal("")),
  code: z.string().optional(), // Optional - will be auto-generated if not provided
});

const UpdateContactSchema = ContactSchema.extend({
  contactId: z.string().uuid(),
});

export async function createContactAction(input: z.infer<typeof ContactSchema>) {
  const payload = ContactSchema.parse(input);
  const user = await getCurrentUser();
  if (!user?.tenant) {
    throw new Error("User tenant not resolved.");
  }

  const supabase = await createServerSupabaseClient();
  const insertData: ContactsInsert = {
    tenant_id: user.tenant.id,
    name: payload.name,
    type: payload.type,
    email: payload.email || null,
    phone: payload.phone || null,
    address: payload.address || null,
    tax_id: payload.tax_id || null,
    // code will be auto-generated by trigger if not provided
    ...(payload.code ? { code: payload.code } : {}),
    is_active: true,
  };

  const table = supabase.from("contacts") as unknown as {
    insert: (values: ContactsInsert[]) => {
      select: (columns?: string) => Promise<{ data: ContactsRow[] | null; error: unknown }>;
    };
  };
  const { data: contacts, error } = await table.insert([insertData]).select("*");
  const data = contacts?.[0] ?? null;

  if (error) {
    console.error("Failed to create contact", error);
    throw error;
  }

  const auditData: AuditLogsInsert = {
    tenant_id: user.tenant.id,
    actor_id: user.id,
    action: "contact.created",
    entity: "contacts",
    entity_id: data?.id ?? null,
    changes: {
      name: payload.name,
      type: payload.type,
      code: data?.code,
    },
  };
  const auditTable = supabase.from("audit_logs") as unknown as {
    insert: (values: AuditLogsInsert[]) => Promise<{ error: unknown }>;
  };
  await auditTable.insert([auditData]);

  revalidatePath("/contacts");
  return data;
}

export async function updateContactAction(input: z.infer<typeof UpdateContactSchema>) {
  const payload = UpdateContactSchema.parse(input);
  const user = await getCurrentUser();
  if (!user?.tenant) {
    throw new Error("User tenant not resolved.");
  }

  const supabase = await createServerSupabaseClient();
  const updateData: ContactsUpdate = {
    name: payload.name,
    type: payload.type,
    email: payload.email || null,
    phone: payload.phone || null,
    address: payload.address || null,
    tax_id: payload.tax_id || null,
  };

  const table = supabase.from("contacts") as unknown as {
    update: (values: ContactsUpdate) => {
      eq: (column: string, value: string) => {
        eq: (column: string, value: string) => Promise<{ error: unknown }>;
      };
    };
  };
  const { error } = await table.update(updateData).eq("id", payload.contactId).eq("tenant_id", user.tenant.id);

  if (error) {
    console.error("Failed to update contact", error);
    throw error;
  }

  const auditData: AuditLogsInsert = {
    tenant_id: user.tenant.id,
    actor_id: user.id,
    action: "contact.updated",
    entity: "contacts",
    entity_id: payload.contactId,
    changes: {
      name: payload.name,
      type: payload.type,
    },
  };
  const auditTable = supabase.from("audit_logs") as unknown as {
    insert: (values: AuditLogsInsert[]) => Promise<{ error: unknown }>;
  };
  await auditTable.insert([auditData]);

  revalidatePath("/contacts");
  return { success: true };
}

export async function deleteContactAction(contactId: string) {
  const user = await getCurrentUser();
  if (!user?.tenant) {
    throw new Error("User tenant not resolved.");
  }

  const supabase = await createServerSupabaseClient();
  const updateData: ContactsUpdate = {
    is_active: false,
  };

  const table = supabase.from("contacts") as unknown as {
    update: (values: ContactsUpdate) => {
      eq: (column: string, value: string) => {
        eq: (column: string, value: string) => Promise<{ error: unknown }>;
      };
    };
  };
  const { error } = await table.update(updateData).eq("id", contactId).eq("tenant_id", user.tenant.id);

  if (error) {
    console.error("Failed to delete contact", error);
    throw error;
  }

  const auditData: AuditLogsInsert = {
    tenant_id: user.tenant.id,
    actor_id: user.id,
    action: "contact.deleted",
    entity: "contacts",
    entity_id: contactId,
    changes: null,
  };
  const auditTable = supabase.from("audit_logs") as unknown as {
    insert: (values: AuditLogsInsert[]) => Promise<{ error: unknown }>;
  };
  await auditTable.insert([auditData]);

  revalidatePath("/contacts");
  return { success: true };
}

export async function getContactStatementAction(contactId: string) {
  const { getContactStatement } = await import("@/lib/data/contacts");
  return await getContactStatement(contactId);
}
